import Foundation
import Flutter
import Security
import CommonCrypto

/// Native iOS plugin for certificate pinning with SPKI SHA-256
///
/// Provides TRUE SPKI (SubjectPublicKeyInfo) SHA-256 hashing that is
/// compatible with pins generated by:
/// openssl s_client ... | openssl x509 -pubkey -noout | openssl pkey -pubin -outform der | openssl dgst -sha256 -binary | openssl enc -base64
class CertPinningPlugin: NSObject, FlutterPlugin, URLSessionDelegate {
    
    private var allowedPins: [String] = []
    private var bypassEnabled: Bool = false
    
    static func register(with registrar: FlutterPluginRegistrar) {
        let channel = FlutterMethodChannel(
            name: "mil_readiness_app/cert_pinning",
            binaryMessenger: registrar.messenger()
        )
        let instance = CertPinningPlugin()
        registrar.addMethodCallDelegate(instance, channel: channel)
    }
    
    func handle(_ call: FlutterMethodCall, result: @escaping FlutterResult) {
        switch call.method {
        case "configurePins":
            guard let args = call.arguments as? [String: Any],
                  let pins = args["pins"] as? [String] else {
                result(FlutterError(code: "INVALID_ARGS", message: "Missing pins array", details: nil))
                return
            }
            let bypass = args["bypassEnabled"] as? Bool ?? false
            configurePins(pins: pins, bypassEnabled: bypass)
            result(["success": true])
            
        case "validateUrl":
            guard let args = call.arguments as? [String: Any],
                  let urlString = args["url"] as? String else {
                result(FlutterError(code: "INVALID_ARGS", message: "Missing url", details: nil))
                return
            }
            validateUrl(urlString: urlString, result: result)
            
        case "extractServerPin":
            guard let args = call.arguments as? [String: Any],
                  let urlString = args["url"] as? String else {
                result(FlutterError(code: "INVALID_ARGS", message: "Missing url", details: nil))
                return
            }
            extractServerPin(urlString: urlString, result: result)
            
        default:
            result(FlutterMethodNotImplemented)
        }
    }
    
    /// Configure allowed pins and bypass mode
    private func configurePins(pins: [String], bypassEnabled: Bool) {
        self.allowedPins = pins
        self.bypassEnabled = bypassEnabled
    }
    
    /// Validate a URL against configured pins
    private func validateUrl(urlString: String, result: @escaping FlutterResult) {
        guard let url = URL(string: urlString) else {
            result(["valid": false, "error": "Invalid URL"])
            return
        }
        
        if allowedPins.isEmpty {
            result(["valid": false, "error": "No pins configured"])
            return
        }
        
        let session = URLSession(configuration: .default, delegate: self, delegateQueue: nil)
        let task = session.dataTask(with: url) { [weak self] data, response, error in
            if let error = error {
                // Check if it's a pinning failure we caused
                if (error as NSError).code == NSURLErrorCancelled {
                    result(["valid": false, "error": "Certificate pinning failed"])
                } else {
                    result(["valid": false, "error": error.localizedDescription])
                }
            } else {
                result(["valid": true])
            }
        }
        task.resume()
    }
    
    /// Extract the SPKI SHA-256 pin from a server for configuration
    private func extractServerPin(urlString: String, result: @escaping FlutterResult) {
        guard let url = URL(string: urlString) else {
            result(["success": false, "error": "Invalid URL"])
            return
        }
        
        // Use a custom session that captures the certificate
        let session = URLSession(configuration: .default, delegate: PinExtractor(completion: { pin in
            if let pin = pin {
                result(["success": true, "pin": pin])
            } else {
                result(["success": false, "error": "Could not extract pin"])
            }
        }), delegateQueue: nil)
        
        let task = session.dataTask(with: url) { _, _, _ in }
        task.resume()
    }
    
    // MARK: - URLSessionDelegate
    
    func urlSession(_ session: URLSession, 
                    didReceive challenge: URLAuthenticationChallenge, 
                    completionHandler: @escaping (URLSession.AuthChallengeDisposition, URLCredential?) -> Void) {
        
        guard challenge.protectionSpace.authenticationMethod == NSURLAuthenticationMethodServerTrust,
              let serverTrust = challenge.protectionSpace.serverTrust else {
            completionHandler(.performDefaultHandling, nil)
            return
        }
        
        // Get the leaf certificate (first in chain)
        guard let certificate = SecTrustCopyCertificateChain(serverTrust) as? [SecCertificate],
              let leafCert = certificate.first else {
            completionHandler(.cancelAuthenticationChallenge, nil)
            return
        }
        
        // Extract SPKI and compute SHA-256 hash
        guard let spkiHash = extractSpkiSha256(from: leafCert) else {
            if bypassEnabled {
                completionHandler(.performDefaultHandling, nil)
            } else {
                completionHandler(.cancelAuthenticationChallenge, nil)
            }
            return
        }
        
        let pin = "sha256/\(spkiHash)"
        
        // Check if pin matches
        if allowedPins.contains(pin) {
            completionHandler(.useCredential, URLCredential(trust: serverTrust))
        } else if bypassEnabled {
            // Bypass enabled (dev mode only)
            completionHandler(.performDefaultHandling, nil)
        } else {
            // FAIL CLOSED - reject connection
            completionHandler(.cancelAuthenticationChallenge, nil)
        }
    }
    
    /// Extract SPKI SHA-256 hash from certificate
    /// 
    /// This produces a hash compatible with:
    /// openssl s_client ... | openssl x509 -pubkey -noout | openssl pkey -pubin -outform der | openssl dgst -sha256 -binary | openssl enc -base64
    private func extractSpkiSha256(from certificate: SecCertificate) -> String? {
        // Get public key from certificate
        guard let publicKey = SecCertificateCopyKey(certificate) else {
            return nil
        }
        
        // Export public key as DER (this IS the SubjectPublicKeyInfo)
        var error: Unmanaged<CFError>?
        guard let publicKeyData = SecKeyCopyExternalRepresentation(publicKey, &error) as Data? else {
            return nil
        }
        
        // For RSA keys, we need to add the ASN.1 header to make proper SPKI
        // For EC keys, SecKeyCopyExternalRepresentation returns raw key data
        let spkiData: Data
        let keyType = SecKeyGetBlockSize(publicKey)
        
        if keyType >= 256 { // RSA key
            spkiData = addRsaSpkiHeader(to: publicKeyData)
        } else { // EC key
            spkiData = addEcSpkiHeader(to: publicKeyData)
        }
        
        // Compute SHA-256 hash
        var hash = [UInt8](repeating: 0, count: Int(CC_SHA256_DIGEST_LENGTH))
        spkiData.withUnsafeBytes { bytes in
            _ = CC_SHA256(bytes.baseAddress, CC_LONG(spkiData.count), &hash)
        }
        
        // Return base64 encoded hash
        return Data(hash).base64EncodedString()
    }
    
    /// Add ASN.1 header for RSA SubjectPublicKeyInfo
    private func addRsaSpkiHeader(to publicKeyData: Data) -> Data {
        // ASN.1 header for RSA public key (2048-bit)
        let rsaHeader: [UInt8] = [
            0x30, 0x82, 0x01, 0x22, // SEQUENCE (290 bytes)
            0x30, 0x0D,             // SEQUENCE
            0x06, 0x09,             // OID
            0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x01, // rsaEncryption
            0x05, 0x00,             // NULL
            0x03, 0x82, 0x01, 0x0F, // BIT STRING
            0x00                    // unused bits
        ]
        
        var result = Data(rsaHeader)
        result.append(publicKeyData)
        return result
    }
    
    /// Add ASN.1 header for EC SubjectPublicKeyInfo (P-256)
    private func addEcSpkiHeader(to publicKeyData: Data) -> Data {
        // ASN.1 header for EC public key (P-256)
        let ecHeader: [UInt8] = [
            0x30, 0x59,             // SEQUENCE (89 bytes)
            0x30, 0x13,             // SEQUENCE
            0x06, 0x07,             // OID (7 bytes)
            0x2A, 0x86, 0x48, 0xCE, 0x3D, 0x02, 0x01, // ecPublicKey
            0x06, 0x08,             // OID (8 bytes)
            0x2A, 0x86, 0x48, 0xCE, 0x3D, 0x03, 0x01, 0x07, // prime256v1
            0x03, 0x42,             // BIT STRING (66 bytes)
            0x00                    // unused bits
        ]
        
        var result = Data(ecHeader)
        result.append(publicKeyData)
        return result
    }
}

/// Helper class to extract pins without validation
private class PinExtractor: NSObject, URLSessionDelegate {
    let completion: (String?) -> Void
    
    init(completion: @escaping (String?) -> Void) {
        self.completion = completion
    }
    
    func urlSession(_ session: URLSession,
                    didReceive challenge: URLAuthenticationChallenge,
                    completionHandler: @escaping (URLSession.AuthChallengeDisposition, URLCredential?) -> Void) {
        
        guard challenge.protectionSpace.authenticationMethod == NSURLAuthenticationMethodServerTrust,
              let serverTrust = challenge.protectionSpace.serverTrust,
              let certificates = SecTrustCopyCertificateChain(serverTrust) as? [SecCertificate],
              let leafCert = certificates.first else {
            completion(nil)
            completionHandler(.performDefaultHandling, nil)
            return
        }
        
        // Extract SPKI hash
        guard let publicKey = SecCertificateCopyKey(leafCert),
              let publicKeyData = SecKeyCopyExternalRepresentation(publicKey, nil) as Data? else {
            completion(nil)
            completionHandler(.performDefaultHandling, nil)
            return
        }
        
        // Compute SHA-256
        var hash = [UInt8](repeating: 0, count: Int(CC_SHA256_DIGEST_LENGTH))
        publicKeyData.withUnsafeBytes { bytes in
            _ = CC_SHA256(bytes.baseAddress, CC_LONG(publicKeyData.count), &hash)
        }
        
        let pin = "sha256/\(Data(hash).base64EncodedString())"
        completion(pin)
        
        completionHandler(.performDefaultHandling, nil)
    }
}
